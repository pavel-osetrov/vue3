# Основы

##Введение

Vue - Прогрессивный JavaScript фреймворк, для создания front-end.
Основная документация - https://v3.vuejs.org/guide/introduction.html

**Чем отличается Vue3 от Vue2?

* Vue3 полностью переписан внутри на TypeScrip(строгая типизация нативно) так же оптимизирована реактивность с помощью проксированния.
* Новый способ написания компонентов Composition API.



*В данном коммите реализован Options API (data, methods, computed, watch).


**Отличие Vue от React и Angular?

* React(Facebook) - низкоуровневая библиотека, с его помощью можно добится высокой производительности.
* Angular(Google) - Основная область применения Enterprice. Большие проекты.
* VueJS - Более высокая абстракция, отлично подходит для маленьких и средних проектов (интернет-магазин, CRM)

Резюмируя, фреймворк стоит подбирать под задачу.

## Начало работы

There are four primary ways of adding Vue.js to a project:

1. Import it as a CDN package on the page
2. Download the JavaScript files and host them yourself
3. Install it using npm
4. Use the official CLI to scaffold a project, which provides batteries-included build setups for a modern frontend workflow (e.g., hot-reload, lint-on-save, and much more)


1. CDN
For prototyping or learning purposes, you can use the latest version with:

<script src="https://unpkg.com/vue@next"></script>


## Первый функционал

Инициализация приложения метод createApp

Vue.createApp() - данный метод принимает в себя объект с помощью которого инициализируем и конфигурируем наше приложение.

Существует два вида взаимодействия
* Из JavaScript передаем данные в HTML.
* Совершаем действия в HTML и собщаем об этом в JavaScript.

Для передачи из JS в HTML, есть первая опция data, которая передается в объекте для createApp.
Этот метод должн вернуть объект. 
В этом объекте, как ключ название переменной и ее значение.

* Для вывода данных в HTML во Vue есть интерполяция. {{  }}

Vue требуется сообщить с каким местом в приложении ему стоит работать.
Для этого нужно сделать следующее:

*Выбрать корневой элемент в HTML который будет основным узлом для работы Vue.

<div id="app">

Vue.createApp(App).mount('#app')


## Как работает интерполяция

С помощью интерполяции мы выводим данные из JS в HTML шаблон.
Vue приводит данные к строке.
Делает он это с помощью глобального метода JSON метода stringify = JSON.stringify

## Добавляем пользовательские события

Допустим мы хотим обработать клик по кнопке.
Для этого во Vue используются дерективы, в нашем случае v-on.
v-on задает слушателя для данной кнопки. Говорим какое событие мы хотим послушать:
v-on:click="counter++" в "" мы пишем что мы хотим сделать.

То есть мы не затрагивая JS меняем это прямо в HTML шаблоне. 
Когда я нажимаю на кнопку counter меняется на еденицу, дальше меняется модель в JS. 
Т.е. в методе data() {} изменяется counter.
И после того как поменялась модель меняется и отображение на странице.

## Работа с атрибутами.

C помощью инерполяции {{ }} мы не можем передать значения в атрибуты. 
Для этого есть другой способ.
например, для того чтобы занести в атрибут placeholder значение placeholderString мы должны забаиндить данный атрибут к данной переменной.
Для этого есть деректива v-bind.
v-bind:placeholder="placeholderString"

## Выводим список с помощью директивы v-for

в data () {} есть массив notes
в шаблоне прописываем
<li class="list-item" v-for="(note, idx) in notes">
в конструкции v-for создал переменную note со значением  и idx с индексом. С уканием из какого массива делать итерацию, т.е. notes.


## Добавляем реактивности

Реактивность Vue заключается в том что мы в JS изменяем массив, Vue это видит и меняет то место в шаблоне HTML где произошли изменения.

например по клику на кнопку вызываем метод addNote <button class="btn" v-on:click="addNote">Добавить</button>
methods: {
        addNote() {            
                this.notes.push(this.inputValue)
            }
		}
}


## Модификаторы событий

Задача заключается в том чтобы в input вводить какой-то текст, нажимать enter и чтобы очистился input и добавилась новая заметка.
Если нужно слушать конкретную кнопку Enter, для этого прописываем.

v-on:keypress.enter="addNote"
addNote() {
            if (this.inputValue !== '') {
                this.notes.push(this.inputValue)
                this.inputValue = ''
            }
## Передача параметров в методы

Задача добавить возможность удаления этих заметок.
<li class="list-item" v-for="(note, idx) in notes">

<button class="btn danger" v-on:click="removeNote(idx)">удалить</button>

removeNote(idx) {
            this.notes.splice(idx, 1)
        }
		
Если хотим передать в метод нативный event, то что отдает браузер. для этого пишем $event 

## Условный рендеринг с помощью директивы v-if

Если уловие в v-if правда, то мы выводим блок ul если ложь то выводится div
<ul class="list" v-if="notes.length !== 0">
	
</ul>
<div v-else-if="notes.length === 0">Заметок пока нет, добавьте первую</div>

## Методы в шаблоне

В интерполяции мы можем использовать любые сущности которые мы можем привести к строке. 
Соответственно если медод который мы реализуем возвращяет нам строчку, можем работать с ним:

<span > {{ toUpperCase(note) }}</span>

toUpperCase(item) {
            return item.toUpperCase()
			
## Сокращяем код используя ярлыки.

v-bind: - ярлык :
v-on: - ярлык @


## Оптимизация с помощью свойства computed

computed - объект где мы можем создавать методы.
первое важное правило computed свойств, они должны что-то возвращять. 
Принцип computed (вычисляемых) свойств они должны зависить от переменных которые у нас есть в данном приложении.

В нашем случаем мы зависим от this.notes

{{ doubleCountComputed }} ВАЖНЫЙ момент!!!! 
Computed свойства мы не вызываем, они являются геттерами и сеттерами и поэтому мы обращаемся к ним как к свойству.

Главное что стоит своить по computed свойствам:
Использовать если есть какие-то переменные внутри нашего приложения, от которого мы вычисляем результат.
В нашем случае результат зависит от this.notes то мы можем кинуть в computed и тем самым оптимизируем наше приложение.
метод doubleCountComputed будет вызываться только в том случае если изменилась переменная this.notes 


## Следим за свойствами с помощью watch

Добавляется на один уровень с computed, methods, data. В объект конфигурации нашего приложения.
С помощью Watch мы можем следить за теми свойствами которые захотим.
Создаем метод название которого совпадает с названием переменной inputValue

<watch: {
        inputValue (value) {
            if (value.length > 10 ) {
                this.inputValue = ''
            }
        }
    }>
	
## Hабота с v-model
Двухсороннее связывание с помощью директивы v-model
v-model="inputValue"


## Задаем инлайн стили

Как Vue работает со стилями?
в HTML элемент мы можем забаиндить атрибут style.
:style и прописывать JS объект.

идея в том что в качестве ключа мы можем указывать название того свойства которое хотив менять. Например color.
В качестве значения этого свойства можем указывать условия. В коде ниже с помощью тернавного оператора.

<h1 :style="{
	color: inputValue.length < 5 ? 'darkred' : 'darkblue',
    fontSize: inputValue.length < 6 ? '2rem' : '1.5rem'
}">{{ title }}</h1>


## Работа с классами
с классами есть 3 варианта как их использовать в динамическом формате.

1. работает для добавления одного класса:
<span :class="note.length > 5 ? 'primary' : 'bold'"> {{ idx + 1 }} {{ toUpperCase(note) }} </span>-->

2. 'primary' будет добавлен всегда а 'bold' только в том случае когда выполняется условие. 

<span :class="{
	'primary' : true,
	'bold': note.length > 5
}"> {{ idx + 1 }} {{ toUpperCase(note) }} </span>-->

3. передача массива. Как элемент массива может быть класс либо объект.
<span :class="['bold', {'primary': note.length > 5 }]">({{ idx + 1 }}) {{ toUpperCase(note) }}</span>


